# 第三部分：传输层

## 三次握手和四次挥手机制

![](https://pic.leetcode-cn.com/1614160878-FiFlkq-image.png)

> 通过`三次握手`建立连接
>
> - 首先客户端给服务点发一个SYN报，并等待服务点的确认
>   - SYN表示请求建立连接
>   - 序号Seq = x表示一个随机数
>   - 随后客户端进入 SYN-SENT 阶段
> - 服务器收到客户端的SYN报后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，，其中，
>   - 标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；
>   - 序号为 Seq = y
>   - 确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。
> - 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文
>   - 标志位为 ACK，表示确认收到服务器端同意连接的信号；
>   - 序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；
>   - 确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。
>   - 随后客户端进入 ESTABLISHED。

### 三次握手幽默版

> 先打开对讲机
>
> 客户端 ： 打开对讲机，并开始听对讲机(Listen阶段)
>
> - 客户端 ： 服务端你听到了吗。并发送给服务端 SYN 报，SYN= 1，请听到了吗 ，听到请回答，，并等待确认 seq = x，，并开始等待（SYN-SEND阶段）
>
> - 服务端：服务端收到，并发送 SYN = 1,ACK = 1，听请求 Seq =y, Ack = x+1,并开始等待（说完进入SYN-RCVD阶段）
>
> - 客户端：好的，好的（ACK=1），我要开始跟你讲一件事情（Seq = x+1,Ack = y+1）;(进入 ESTABLISHED阶段)
>
> - - 成员Server:默默的点点头，并对自己说可以（进入 ESTABLISHED阶段）
>
>     





![](https://pic.leetcode-cn.com/1612459478-ajInIu-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)



###  四次挥手幽默版



- 成员client:我事情讲完了，你知道吗（FIN = 1,Seq = u）；（进入FIN-WAIT-1）
- 成员Server:哦，哦（ACK = 1, Seq = v）,知道了（Ack = u+1）,让我再理一下（进入CLOSE-WAIT）
- 成员client:对自己默默说了句，好的，等等你（进入FIN-WAIT-2）
- 成员Server:哦，这个是这么处理对吧，知道了（FIN =1,ACK=1,Seq = w,Ack = u+1）(进入LAST-ACK)
- 成员client:对的，是的（ACK=1,Seq= u+1,Ack = w+1）,并关掉对讲机（close）
- 成员server:听到确认和嘟嘟声，关掉对讲机（close）



### 总结

#### 三次握手：



- C->S：SYN ，seq=x（你能听到吗？）
- S->C：SYN ，seq=y，ack=x+1（我能听到，你能听到吗？）
-  C->S：ACK，seq=x+1，ack=y+1（我能听到，开始吧）

#### 四次挥手：



- C->S：FIN，seq=p（我说完了）
- S->C：ACK，ack=p+1（我知道了，等一下，我可能还没说完）
- S->C：FIN，seq=q，ACK，ack=p+1（我也说完了）
- C->S：ACK，ack=q+1（我知道了，结束吧）





## 如果三次握手的时候每次握手信息对方没有收到会怎么样

### 如果第一次握手SYN丢包

> 服务端没收到客户端发送的建立连接的数据包，服务器没有做任何响应的动作。反而客户端一段是时间内没收来自服务端的确认报文，一段时间后重新发送建立连接的SYN报文，如果仍然仍然没有回应，则重复上次的重传的过程，直到重传次数超过限制的重传次数后，建立连接的系统调用和返回 -1

### 如果第二次握手丢包

> 第二次握手丢包就以为着客户端没有收到来自服务端的任何ACK报文（确认报文），则客户端采取第一次握手的丢包的那个动作，并服务器这时候处于（阻塞）状态调用Accept等待客户端再一次发确认报文（ACK报文）。

### 如果第三次握手丢包

> 服务器没有收到来自客户端的确认报文（ACK报文），同样会采取类似客户端的超时重传机制，如果重传次数超过限制，仍然没有回应，系统调用Accept并返回-1，服务器端连接失败（相当于断开链接）。但是客户端以为已经自己连接成功，，因此开始向服务端开始发送数据，但是服段 accept() 系统调用已返回，此时已经不在监听状态，因此服务器端接收到来自客户端发送来的数据时会发送 RST（RESET） 报文给 客户端，消除客户端单方面建立连接的状态。



## 为什么要进行三次握手？两次握手可以吗？

> 三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。

### 保证双方都是双工通信

- 第一次握手,服务端确定客户端的发送正常
- 第二次握手,客户端确认服务端的收发正常
-  第三次握手,服务端确定客服端接收正常
- 如果只有第二次握手,服务端发给客服端的包丢了之后,服务端就直接建立了连接,然后一直傻等,不会释放,造成阻塞!



## 为什么不是四次握手

> 三次握手理论上已经建立最少可靠资源下建立连接成功，所以不需要第次四握手



## 为什么要四次挥手？

断开连接需要四次握手

- 简单来说就是因为TCP是全双工的，两个方向的连接需要单独关闭。
- 有了四次挥手，才能确保服务端的数据全部传送完毕。



简单的说第一次发送fin 想断开链接的时候，服务端收到并确认告诉正在处理消息，处理完后服务端给我客户端发送可以断开的确认消息，最后客户端收到确认进入close 状态，最后服务端收到来自客户端确认后断开链接



## CLOSE-WAIT 和 TIME-WAIT 的状态和意义

### CLOSE-WAIT 

> CLOSE-WAIT  是收到客户端关闭链接的报文后，为了保证服务点关闭链接之前发送的数据处理，让对方等处理完数据，当服务器处理完数据后再发送fin 关闭报文

### TIME-WAIT 

> 是第四次挥手后,客户端进入的状态,是客户端必要的等待时间,目的是等待:1-服务端的对应端口关闭与客户端发送到服务端的数据到达(可能出现延迟),如果不存在这个步骤就会导致两个问题:
>
> - 客户端立即关闭后,立即又用同样的端口握手并建立通信,此时上次的连接残留的数据包会被误认为是本次的,造成数据异常
> - 客户端直接关闭后,若服务端重新发送 fin 包,客户端就会回应 RST,会报异常,但是其实是没有问题的



原因1：为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报(**此处应该是客户端收到一个非法的报文段，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。**)，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。当网络中存在大量的timewait状态，那么服务器的压力可想而知。

原因2：在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。也就是防止我们上一篇文章 [为什么tcp是三次握手而不是两次握手？](https://zhuanlan.zhihu.com/p/51448333) 中说的：已经失效的连接请求报文段出现在本次连接中。如果没有的话就可能这样：这次连接一挥手完马上就结束了，没有timewait。这次连接中有个迷失在网络中的syn包，然后下次连接又马上开始，下个连接发送syn包，迷失的syn包忽然又到达了对面，所以对面可能同时收到或者不同时间收到请求连接的syn包，然后就出现问题了。



## TCP 协议中的定时器



- 建立连接定时器：顾名思义，该定时器是在建立 TCP 连接的时候使用的，在 TCP 三次握手的过程中，发送方发送 SYN 时，会启动一个定时器（默认为 3 秒），若 SYN 包丢失了，那么 3 秒以后会重新发送 SYN 包，直到达到重传次数。

- 重传定时器：该计时器主要用于 TCP 超时重传机制中，当TCP 发送报文段时，就会创建特定报文的重传计时器.

## TCP 是如何保证可靠性的

- 数据分块，是最合适发送方法
- 校验和 ： 防止数据反转，保证数据传输过程中不发生变换
- 重传：防止丢包
- 序列号和确认：防止数据出错，如果出错的话，重发序列号的数据
- 阻塞控制：网络上节点发生阻塞的时候，减少发送的数据
- 流量控制：发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。










